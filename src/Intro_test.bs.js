// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Records = /* module */[];

describe("Basic types", (function () {
        describe("Booleans", (function () {
                Jest.test("negation", (function (param) {
                        return Jest.Expect[/* toBe */2](false, Jest.Expect[/* expect */0](false));
                      }));
                Jest.test("and", (function (param) {
                        return Jest.Expect[/* toBe */2](false, Jest.Expect[/* expect */0](false));
                      }));
                return Jest.test("or", (function (param) {
                              return Jest.Expect[/* toBe */2](false, Jest.Expect[/* expect */0](false));
                            }));
              }));
        describe("Strings and Chars", (function () {
                Jest.test("String concatenation", (function (param) {
                        return Jest.Expect[/* toBe */2]("abcabc", Jest.Expect[/* expect */0]("abcabc"));
                      }));
                Jest.test("multiline strings", (function (param) {
                        return Jest.Expect[/* toBe */2]("abc\nabc", Jest.Expect[/* expect */0]("abc\nabc"));
                      }));
                Jest.test("String length", (function (param) {
                        return Jest.Expect[/* toBe */2](3, Jest.Expect[/* expect */0](3));
                      }));
                Jest.test("char from string", (function (param) {
                        return Jest.Expect[/* toBe */2](/* "b" */98, Jest.Expect[/* expect */0](/* "b" */98));
                      }));
                return Jest.test("string from char", (function (param) {
                              return Jest.Expect[/* toBe */2]("a", Jest.Expect[/* expect */0]($$String.make(1, /* "a" */97)));
                            }));
              }));
        describe("Integers", (function () {
                Jest.test("addition", (function (param) {
                        return Jest.Expect[/* toBe */2](7, Jest.Expect[/* expect */0](7));
                      }));
                Jest.test("subtraction", (function (param) {
                        return Jest.Expect[/* toBe */2](-1, Jest.Expect[/* expect */0](-1));
                      }));
                Jest.test("product", (function (param) {
                        return Jest.Expect[/* toBe */2](15, Jest.Expect[/* expect */0](15));
                      }));
                Jest.test("division", (function (param) {
                        return Jest.Expect[/* toBe */2](3, Jest.Expect[/* expect */0](3));
                      }));
                return Jest.test("mod", (function (param) {
                              return Jest.Expect[/* toBe */2](1, Jest.Expect[/* expect */0](1));
                            }));
              }));
        describe("Floats", (function () {
                Jest.test("addition", (function (param) {
                        return Jest.Expect[/* toBe */2](7, Jest.Expect[/* expect */0](2 + 5));
                      }));
                Jest.test("subtraction", (function (param) {
                        return Jest.Expect[/* toBe */2](-1, Jest.Expect[/* expect */0](3 - 4));
                      }));
                Jest.test("product", (function (param) {
                        return Jest.Expect[/* toBe */2](15, Jest.Expect[/* expect */0](3 * 5));
                      }));
                Jest.test("division", (function (param) {
                        return Jest.Expect[/* toBe */2](3.5, Jest.Expect[/* expect */0](7 / 2));
                      }));
                return Jest.test("exp", (function (param) {
                              return Jest.Expect[/* toBe */2](4, Jest.Expect[/* expect */0](Math.pow(2, 2)));
                            }));
              }));
        describe("unit", (function () {
                Jest.test("equal to itself", (function (param) {
                        return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](true));
                      }));
                return Jest.test("equal to itself", (function (param) {
                              return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](true));
                            }));
              }));
        return /* () */0;
      }));

describe("Infix operators", (function () {
        return Jest.test("can be defined (but only with these characters = < > @ ^ | & + - * / $ %)", (function (param) {
                      var $star$dot$dot$dot$star = function (a, b) {
                        return "start -> here is a: " + (a + ("here is b: " + (b + " -> bye")));
                      };
                      return Jest.Expect[/* toBe */2]("start -> here is a: ahere is b: b -> bye", Jest.Expect[/* expect */0]($star$dot$dot$dot$star("a", "b")));
                    }));
      }));

describe("Tuples", (function () {
        Jest.test("can hold heterogeneous data", (function (param) {
                return Jest.Expect[/* toEqual */12](/* tuple */[
                            1,
                            "hola"
                          ], Jest.Expect[/* expect */0](/* tuple */[
                                1,
                                "hola"
                              ]));
              }));
        return Jest.test("can be destructured (pattern matched)", (function (param) {
                      return Jest.Expect[/* toBe */2]("hola", Jest.Expect[/* expect */0]("hola"));
                    }));
      }));

describe("Lists", (function () {
        Jest.test("can only hold homogeneous data", (function (param) {
                return Jest.Expect[/* toBe */2](2, Jest.Expect[/* expect */0](List.length(/* :: */[
                                    1,
                                    /* :: */[
                                      2,
                                      /* [] */0
                                    ]
                                  ])));
              }));
        Jest.test("can be extended with spread operator", (function (param) {
                var newList_001 = /* :: */[
                  2,
                  /* :: */[
                    3,
                    /* :: */[
                      1,
                      /* :: */[
                        2,
                        /* [] */0
                      ]
                    ]
                  ]
                ];
                var newList = /* :: */[
                  1,
                  newList_001
                ];
                return Jest.Expect[/* toEqual */12](/* :: */[
                            1,
                            /* :: */[
                              2,
                              /* :: */[
                                3,
                                /* :: */[
                                  1,
                                  /* :: */[
                                    2,
                                    /* [] */0
                                  ]
                                ]
                              ]
                            ]
                          ], Jest.Expect[/* expect */0](newList));
              }));
        Jest.test("can be concatenated with @ operator", (function (param) {
                return Jest.Expect[/* toEqual */12](/* :: */[
                            "a",
                            /* :: */[
                              "b",
                              /* :: */[
                                "c",
                                /* :: */[
                                  "d",
                                  /* [] */0
                                ]
                              ]
                            ]
                          ], Jest.Expect[/* expect */0](Pervasives.$at(/* :: */[
                                    "a",
                                    /* :: */[
                                      "b",
                                      /* [] */0
                                    ]
                                  ], /* :: */[
                                    "c",
                                    /* :: */[
                                      "d",
                                      /* [] */0
                                    ]
                                  ])));
              }));
        Jest.test("can be mapped, reduced, etc", (function (param) {
                return Jest.Expect[/* toEqual */12](/* :: */[
                            2,
                            /* :: */[
                              3,
                              /* :: */[
                                4,
                                /* [] */0
                              ]
                            ]
                          ], Jest.Expect[/* expect */0](List.map((function (a) {
                                      return a + 1 | 0;
                                    }), /* :: */[
                                    1,
                                    /* :: */[
                                      2,
                                      /* :: */[
                                        3,
                                        /* [] */0
                                      ]
                                    ]
                                  ])));
              }));
        return Jest.test("can be destructured (pattern matched)", (function (param) {
                      return Jest.Expect[/* toEqual */12](/* :: */[
                                  2,
                                  /* [] */0
                                ], Jest.Expect[/* expect */0](/* :: */[
                                      2,
                                      /* [] */0
                                    ]));
                    }));
      }));

describe("Arrays", (function () {
        Jest.test("can only hold homogeneous data", (function (param) {
                var myArray = /* array */[
                  1,
                  2
                ];
                return Jest.Expect[/* toBe */2](2, Jest.Expect[/* expect */0](myArray.length));
              }));
        Jest.test("can be accessed by index with bracket notation", (function (param) {
                var myArray = /* array */[
                  1,
                  2
                ];
                return Jest.Expect[/* toBe */2](1, Jest.Expect[/* expect */0](Caml_array.caml_array_get(myArray, 0)));
              }));
        Jest.test("are mutable", (function (param) {
                var myArray = /* array */[
                  1,
                  2
                ];
                Caml_array.caml_array_set(myArray, 0, 0);
                return Jest.Expect[/* toBe */2](0, Jest.Expect[/* expect */0](Caml_array.caml_array_get(myArray, 0)));
              }));
        Jest.test("can be mapped, reduced, etc", (function (param) {
                return Jest.Expect[/* toEqual */12](/* array */[
                            2,
                            3,
                            4
                          ], Jest.Expect[/* expect */0]($$Array.map((function (a) {
                                      return a + 1 | 0;
                                    }), /* array */[
                                    1,
                                    2,
                                    3
                                  ])));
              }));
        return Jest.test("can be destructured (pattern matched)", (function (param) {
                      var match = /* array */[
                        1,
                        2
                      ];
                      if (match.length !== 2) {
                        throw [
                              Caml_builtin_exceptions.match_failure,
                              /* tuple */[
                                "Intro_test.re",
                                176,
                                8
                              ]
                            ];
                      } else {
                        var first = match[0];
                        var second = match[1];
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    2,
                                    1
                                  ], Jest.Expect[/* expect */0](/* array */[
                                        second,
                                        first
                                      ]));
                      }
                    }));
      }));

describe("Records", (function () {
        Jest.test("allow access to their fields with dot notation", (function (param) {
                return Jest.Expect[/* toBe */2](4, Jest.Expect[/* expect */0](4));
              }));
        Jest.test("are immutable by default", (function (param) {
                return Jest.Expect[/* toBe */2](4, Jest.Expect[/* expect */0](4));
              }));
        Jest.test("can be made mutable", (function (param) {
                var myPoint = /* record */[
                  /* x */4,
                  /* y */5
                ];
                myPoint[/* x */0] = 1;
                return Jest.Expect[/* toBe */2](1, Jest.Expect[/* expect */0](myPoint[/* x */0]));
              }));
        Jest.test("can be parametrized at declaration", (function (param) {
                return Jest.Expect[/* toBe */2]("hola", Jest.Expect[/* expect */0]("hola"));
              }));
        Jest.test("can be spread to form new records", (function (param) {
                return Jest.Expect[/* toBe */2](10, Jest.Expect[/* expect */0](10));
              }));
        return Jest.test("can be destructured (pattern matched)", (function (param) {
                      return Jest.Expect[/* toBe */2](3, Jest.Expect[/* expect */0](3));
                    }));
      }));

describe("Equality", (function () {
        Jest.test("Structural(==): tuples", (function (param) {
                return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](Caml_obj.caml_equal(/* tuple */[
                                    1,
                                    "abc"
                                  ], /* tuple */[
                                    1,
                                    "abc"
                                  ])));
              }));
        Jest.test("Structural(==): nested tuples", (function (param) {
                return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](Caml_obj.caml_equal(/* tuple */[
                                    1,
                                    /* tuple */[
                                      "abc",
                                      "abc"
                                    ]
                                  ], /* tuple */[
                                    1,
                                    /* tuple */[
                                      "abc",
                                      "abc"
                                    ]
                                  ])));
              }));
        Jest.test("Structural(==): records", (function (param) {
                return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](Caml_obj.caml_equal(/* record */[
                                    /* x */2,
                                    /* y */3
                                  ], /* record */[
                                    /* x */2,
                                    /* y */3
                                  ])));
              }));
        Jest.test("Structural(==): recursive data structures", (function (param) {
                return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](Caml_obj.caml_equal(/* Node */Block.__(0, [
                                      2,
                                      /* Node */Block.__(0, [
                                          1,
                                          /* Leaf */Block.__(1, [5]),
                                          /* Leaf */Block.__(1, [9])
                                        ]),
                                      /* Leaf */Block.__(1, [3])
                                    ]), /* Node */Block.__(0, [
                                      2,
                                      /* Node */Block.__(0, [
                                          1,
                                          /* Leaf */Block.__(1, [5]),
                                          /* Leaf */Block.__(1, [9])
                                        ]),
                                      /* Leaf */Block.__(1, [3])
                                    ]))));
              }));
        Jest.test("Referential(===) 1", (function (param) {
                var myTuple = /* tuple */[
                  1,
                  "abc"
                ];
                return Jest.Expect[/* toBe */2](true, Jest.Expect[/* expect */0](myTuple === myTuple));
              }));
        return Jest.test("Referential(===) 2", (function (param) {
                      return Jest.Expect[/* toBe */2](false, Jest.Expect[/* expect */0](/* tuple */[
                                      1,
                                      "abc"
                                    ] === /* tuple */[
                                      1,
                                      "abc"
                                    ]));
                    }));
      }));

exports.Records = Records;
/*  Not a pure module */
